package models

import (
	"encoding/json"
	"fmt"
	"gorilla-client/utils"
)

// This contains a record, generated by the server, of the results of the actions
type Trace struct {
	Id            int `json:"id"`
	Simulation_id int `json:"simulation_id"`
	TimeStamp     int
	UserName      string `json:"username"`
	Level         int    `json:"level"`
	Message       string `json:"message"`
}

// Wrapper for the TraceList. We don't need to distinguish between
// viewed and compared fields for the trace table so we
// have a separate template loader method.
func Traces(u *User) *[]Trace {
	var table Table
	table, ok := (*u.GetCurrentStage())["trace"]
	if !ok {
		fmt.Println("Something went wrong loading the trace table")
		return nil
	}

	// This stuff is just for information.
	// Would be good to catch gap irregularities, not because
	// it should be verboten but because it draws attention
	// to trace info that might confuse the user.
	var currentLevel int
	currentLevel = 1
	t := table.Table.(*[]Trace)
	for i := range *t {
		item := (*t)[i]
		// fmt.Println("Processing", item.Level, item.Message)
		if item.Level > currentLevel {
			// fmt.Println("Dropping one level to ", item.Level)
			currentLevel = item.Level
		}
		if item.Level < currentLevel {
			// fmt.Println("Going up to ", item.Level)
			if currentLevel-item.Level > 1 {
				fmt.Println(utils.Red + "Gap is greater than 1" + utils.Reset)
				fmt.Println(item.Message)
			}
			currentLevel = item.Level
		}
	}
	return t
}

// Custom MarshalJSON to suppress printout of Trace Records
// TODO suppress entire Trace table (which is a map, so I haven't yet found out how to do this)
// TODO I think it involves checking the actual name of the key but then avoiding infinite recursion
func (i Trace) MarshalJSON() ([]byte, error) {
	return json.Marshal(&struct {
		Tldr string `json:"tldr"`
	}{
		Tldr: "Trace record suppressed",
	})
}
